// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: speech.proto

package asr

import (
	context "context"
	fmt "fmt"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	common "smartest-go/proto/common"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type WakeupStatus int32

const (
	WakeupStatus_NO_WAKEUP      WakeupStatus = 0
	WakeupStatus_WAKEUP_SUCCESS WakeupStatus = 1
	WakeupStatus_HAD_WAKEUP     WakeupStatus = 2
)

var WakeupStatus_name = map[int32]string{
	0: "NO_WAKEUP",
	1: "WAKEUP_SUCCESS",
	2: "HAD_WAKEUP",
}

var WakeupStatus_value = map[string]int32{
	"NO_WAKEUP":      0,
	"WAKEUP_SUCCESS": 1,
	"HAD_WAKEUP":     2,
}

func (x WakeupStatus) String() string {
	return proto.EnumName(WakeupStatus_name, int32(x))
}

func (WakeupStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{0}
}

type AsrsLang int32

const (
	AsrsLang_LANG_KEEP    AsrsLang = 0
	AsrsLang_LANG_CH      AsrsLang = 1
	AsrsLang_LANG_EN      AsrsLang = 2
	AsrsLang_LANG_SICHUAN AsrsLang = 3
	AsrsLang_LANG_YUEYU   AsrsLang = 4
)

var AsrsLang_name = map[int32]string{
	0: "LANG_KEEP",
	1: "LANG_CH",
	2: "LANG_EN",
	3: "LANG_SICHUAN",
	4: "LANG_YUEYU",
}

var AsrsLang_value = map[string]int32{
	"LANG_KEEP":    0,
	"LANG_CH":      1,
	"LANG_EN":      2,
	"LANG_SICHUAN": 3,
	"LANG_YUEYU":   4,
}

func (x AsrsLang) String() string {
	return proto.EnumName(AsrsLang_name, int32(x))
}

func (AsrsLang) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{1}
}

type Body_Type int32

const (
	Body_BLOCK     Body_Type = 0
	Body_STREAMING Body_Type = 1
)

var Body_Type_name = map[int32]string{
	0: "BLOCK",
	1: "STREAMING",
}

var Body_Type_value = map[string]int32{
	"BLOCK":     0,
	"STREAMING": 1,
}

func (x Body_Type) String() string {
	return proto.EnumName(Body_Type_name, int32(x))
}

func (Body_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{0, 0}
}

type Body struct {
	Type       Body_Type         `protobuf:"varint,9,opt,name=type,proto3,enum=skill.asr.Body_Type" json:"type,omitempty"`
	Sid        string            `protobuf:"bytes,10,opt,name=sid,proto3" json:"sid,omitempty"`
	AppType    string            `protobuf:"bytes,11,opt,name=app_type,json=appType,proto3" json:"app_type,omitempty"`
	Tag        string            `protobuf:"bytes,12,opt,name=tag,proto3" json:"tag,omitempty"`
	StreamFlag int32             `protobuf:"varint,13,opt,name=stream_flag,json=streamFlag,proto3" json:"stream_flag,omitempty"`
	Option     map[string]string `protobuf:"bytes,14,rep,name=option,proto3" json:"option,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// keys contains recognizeOnly=anything, will not call service app any more
	// keys contains returnDetail=anything, will return a more key named "detailMessage" in the return value
	Data                 *Body_Data `protobuf:"bytes,15,opt,name=data,proto3" json:"data,omitempty"`
	NeedWakeup           bool       `protobuf:"varint,16,opt,name=need_wakeup,json=needWakeup,proto3" json:"need_wakeup,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Body) Reset()         { *m = Body{} }
func (m *Body) String() string { return proto.CompactTextString(m) }
func (*Body) ProtoMessage()    {}
func (*Body) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{0}
}
func (m *Body) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Body) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Body.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Body) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Body.Merge(m, src)
}
func (m *Body) XXX_Size() int {
	return m.Size()
}
func (m *Body) XXX_DiscardUnknown() {
	xxx_messageInfo_Body.DiscardUnknown(m)
}

var xxx_messageInfo_Body proto.InternalMessageInfo

func (m *Body) GetType() Body_Type {
	if m != nil {
		return m.Type
	}
	return Body_BLOCK
}

func (m *Body) GetSid() string {
	if m != nil {
		return m.Sid
	}
	return ""
}

func (m *Body) GetAppType() string {
	if m != nil {
		return m.AppType
	}
	return ""
}

func (m *Body) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *Body) GetStreamFlag() int32 {
	if m != nil {
		return m.StreamFlag
	}
	return 0
}

func (m *Body) GetOption() map[string]string {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *Body) GetData() *Body_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Body) GetNeedWakeup() bool {
	if m != nil {
		return m.NeedWakeup
	}
	return false
}

type Body_Data struct {
	Rate     int32  `protobuf:"varint,1,opt,name=rate,proto3" json:"rate,omitempty"`
	Format   string `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
	Account  string `protobuf:"bytes,3,opt,name=account,proto3" json:"account,omitempty"`
	Language string `protobuf:"bytes,4,opt,name=language,proto3" json:"language,omitempty"`
	Dialect  string `protobuf:"bytes,5,opt,name=dialect,proto3" json:"dialect,omitempty"`
	// when vendor=Baidu then "http://ai.baidu.com/docs#/ASR-Online-Java-SDK/top" for section "dev_pid 参数列表"
	// when vendor=IFlyTek then "https://doc.xfyun.cn/rest_api/%E8%AF%AD%E9%9F%B3%E5%90%AC%E5%86%99.html" for section "6.1.2. 业务参数" "engine_type"
	Vendor               string   `protobuf:"bytes,6,opt,name=vendor,proto3" json:"vendor,omitempty"`
	Channel              int32    `protobuf:"varint,7,opt,name=channel,proto3" json:"channel,omitempty"`
	Duration             int32    `protobuf:"varint,8,opt,name=duration,proto3" json:"duration,omitempty"`
	Flag                 int32    `protobuf:"varint,9,opt,name=flag,proto3" json:"flag,omitempty"`
	Speech               []byte   `protobuf:"bytes,10,opt,name=speech,json=-,proto3" json:"speech,omitempty"`
	MulAsrLang           AsrsLang `protobuf:"varint,11,opt,name=mulAsrLang,proto3,enum=skill.asr.AsrsLang" json:"mulAsrLang,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Body_Data) Reset()         { *m = Body_Data{} }
func (m *Body_Data) String() string { return proto.CompactTextString(m) }
func (*Body_Data) ProtoMessage()    {}
func (*Body_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{0, 1}
}
func (m *Body_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Body_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Body_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Body_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Body_Data.Merge(m, src)
}
func (m *Body_Data) XXX_Size() int {
	return m.Size()
}
func (m *Body_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_Body_Data.DiscardUnknown(m)
}

var xxx_messageInfo_Body_Data proto.InternalMessageInfo

func (m *Body_Data) GetRate() int32 {
	if m != nil {
		return m.Rate
	}
	return 0
}

func (m *Body_Data) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *Body_Data) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *Body_Data) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Body_Data) GetDialect() string {
	if m != nil {
		return m.Dialect
	}
	return ""
}

func (m *Body_Data) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *Body_Data) GetChannel() int32 {
	if m != nil {
		return m.Channel
	}
	return 0
}

func (m *Body_Data) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Body_Data) GetFlag() int32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

func (m *Body_Data) GetSpeech() []byte {
	if m != nil {
		return m.Speech
	}
	return nil
}

func (m *Body_Data) GetMulAsrLang() AsrsLang {
	if m != nil {
		return m.MulAsrLang
	}
	return AsrsLang_LANG_KEEP
}

type RecognitionRequest struct {
	CommonReqInfo        *common.CommonReqInfo `protobuf:"bytes,1,opt,name=common_req_info,json=commonReqInfo,proto3" json:"common_req_info,omitempty"`
	Body                 *Body                 `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	Extra                *common.Extra         `protobuf:"bytes,3,opt,name=extra,proto3" json:"extra,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *RecognitionRequest) Reset()         { *m = RecognitionRequest{} }
func (m *RecognitionRequest) String() string { return proto.CompactTextString(m) }
func (*RecognitionRequest) ProtoMessage()    {}
func (*RecognitionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{1}
}
func (m *RecognitionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecognitionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecognitionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecognitionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecognitionRequest.Merge(m, src)
}
func (m *RecognitionRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecognitionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecognitionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecognitionRequest proto.InternalMessageInfo

func (m *RecognitionRequest) GetCommonReqInfo() *common.CommonReqInfo {
	if m != nil {
		return m.CommonReqInfo
	}
	return nil
}

func (m *RecognitionRequest) GetBody() *Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *RecognitionRequest) GetExtra() *common.Extra {
	if m != nil {
		return m.Extra
	}
	return nil
}

type RecognitionResponse struct {
	CommonRspInfo        *common.CommonRspInfo `protobuf:"bytes,1,opt,name=common_rsp_info,json=commonRspInfo,proto3" json:"common_rsp_info,omitempty"`
	DetailMessage        *types.Struct         `protobuf:"bytes,2,opt,name=detail_message,json=detailMessage,proto3" json:"detail_message,omitempty"`
	IsNoise              bool                  `protobuf:"varint,3,opt,name=is_noise,json=isNoise,proto3" json:"is_noise,omitempty"`
	QuestionId           string                `protobuf:"bytes,4,opt,name=question_id,json=questionId,proto3" json:"question_id,omitempty"`
	IsWakeup             bool                  `protobuf:"varint,5,opt,name=is_wakeup,json=isWakeup,proto3" json:"is_wakeup,omitempty"`
	WakeupStatus         WakeupStatus          `protobuf:"varint,6,opt,name=wakeup_status,json=wakeupStatus,proto3,enum=skill.asr.WakeupStatus" json:"wakeup_status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *RecognitionResponse) Reset()         { *m = RecognitionResponse{} }
func (m *RecognitionResponse) String() string { return proto.CompactTextString(m) }
func (*RecognitionResponse) ProtoMessage()    {}
func (*RecognitionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{2}
}
func (m *RecognitionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecognitionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecognitionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecognitionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecognitionResponse.Merge(m, src)
}
func (m *RecognitionResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecognitionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecognitionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecognitionResponse proto.InternalMessageInfo

func (m *RecognitionResponse) GetCommonRspInfo() *common.CommonRspInfo {
	if m != nil {
		return m.CommonRspInfo
	}
	return nil
}

func (m *RecognitionResponse) GetDetailMessage() *types.Struct {
	if m != nil {
		return m.DetailMessage
	}
	return nil
}

func (m *RecognitionResponse) GetIsNoise() bool {
	if m != nil {
		return m.IsNoise
	}
	return false
}

func (m *RecognitionResponse) GetQuestionId() string {
	if m != nil {
		return m.QuestionId
	}
	return ""
}

func (m *RecognitionResponse) GetIsWakeup() bool {
	if m != nil {
		return m.IsWakeup
	}
	return false
}

func (m *RecognitionResponse) GetWakeupStatus() WakeupStatus {
	if m != nil {
		return m.WakeupStatus
	}
	return WakeupStatus_NO_WAKEUP
}

type CheckCmd struct {
	Action               string   `protobuf:"bytes,1,opt,name=action,proto3" json:"action,omitempty"`
	Status               int32    `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	CmdDsc               string   `protobuf:"bytes,3,opt,name=cmdDsc,proto3" json:"cmdDsc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckCmd) Reset()         { *m = CheckCmd{} }
func (m *CheckCmd) String() string { return proto.CompactTextString(m) }
func (*CheckCmd) ProtoMessage()    {}
func (*CheckCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{3}
}
func (m *CheckCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckCmd.Merge(m, src)
}
func (m *CheckCmd) XXX_Size() int {
	return m.Size()
}
func (m *CheckCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckCmd.DiscardUnknown(m)
}

var xxx_messageInfo_CheckCmd proto.InternalMessageInfo

func (m *CheckCmd) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *CheckCmd) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *CheckCmd) GetCmdDsc() string {
	if m != nil {
		return m.CmdDsc
	}
	return ""
}

func init() {
	proto.RegisterEnum("skill.asr.WakeupStatus", WakeupStatus_name, WakeupStatus_value)
	proto.RegisterEnum("skill.asr.AsrsLang", AsrsLang_name, AsrsLang_value)
	proto.RegisterEnum("skill.asr.Body_Type", Body_Type_name, Body_Type_value)
	proto.RegisterType((*Body)(nil), "skill.asr.Body")
	proto.RegisterMapType((map[string]string)(nil), "skill.asr.Body.OptionEntry")
	proto.RegisterType((*Body_Data)(nil), "skill.asr.Body.Data")
	proto.RegisterType((*RecognitionRequest)(nil), "skill.asr.RecognitionRequest")
	proto.RegisterType((*RecognitionResponse)(nil), "skill.asr.RecognitionResponse")
	proto.RegisterType((*CheckCmd)(nil), "skill.asr.CheckCmd")
}

func init() { proto.RegisterFile("speech.proto", fileDescriptor_93c8715332746f2c) }

var fileDescriptor_93c8715332746f2c = []byte{
	// 969 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xae, 0xd3, 0xfc, 0x9e, 0xfc, 0xac, 0x99, 0x5d, 0x58, 0x93, 0x85, 0x10, 0x65, 0x6f, 0xa2,
	0x4a, 0xeb, 0x42, 0x2a, 0x24, 0x40, 0x80, 0x94, 0xa6, 0x61, 0x5b, 0xb5, 0x4d, 0xab, 0x71, 0xa3,
	0x55, 0xb9, 0xb1, 0xa6, 0xf6, 0xd4, 0xb5, 0x6a, 0x7b, 0x5c, 0xcf, 0xb8, 0xbb, 0xe1, 0x49, 0xb8,
	0x80, 0x1b, 0x6e, 0xe1, 0x41, 0xb8, 0xe4, 0x11, 0x50, 0xb9, 0xe1, 0x31, 0xd0, 0xcc, 0x38, 0xc5,
	0xbb, 0x0b, 0x5c, 0x71, 0xe5, 0xf9, 0xce, 0xcf, 0x9c, 0x6f, 0xce, 0xf9, 0x8e, 0xa1, 0xc3, 0x53,
	0x4a, 0xbd, 0x2b, 0x3b, 0xcd, 0x98, 0x60, 0xa8, 0xc5, 0xaf, 0xc3, 0x28, 0xb2, 0x09, 0xcf, 0xfa,
	0x5b, 0x3c, 0x26, 0x99, 0xb8, 0x65, 0xa1, 0x47, 0x9f, 0x11, 0x9e, 0x79, 0x22, 0x8b, 0xb6, 0x49,
	0x1a, 0x6e, 0x7b, 0x2c, 0x8e, 0x59, 0x52, 0x7c, 0x74, 0x5a, 0xff, 0x83, 0x80, 0xb1, 0x20, 0xa2,
	0xdb, 0x0a, 0x5d, 0xe4, 0x97, 0xdb, 0x5c, 0x64, 0xb9, 0x27, 0xb4, 0x77, 0xf4, 0x43, 0x0d, 0xaa,
	0xbb, 0xcc, 0x5f, 0xa1, 0x31, 0x54, 0xc5, 0x2a, 0xa5, 0x56, 0x6b, 0x68, 0x8c, 0x7b, 0x93, 0x47,
	0xf6, 0x7d, 0x31, 0x5b, 0xba, 0xed, 0xb3, 0x55, 0x4a, 0xb1, 0x8a, 0x40, 0x26, 0x6c, 0xf2, 0xd0,
	0xb7, 0x60, 0x68, 0x8c, 0x5b, 0x58, 0x1e, 0xd1, 0xfb, 0xd0, 0x24, 0x69, 0xea, 0xaa, 0xfc, 0xb6,
	0x32, 0x37, 0x48, 0x9a, 0x9e, 0x15, 0xc1, 0x82, 0x04, 0x56, 0x47, 0x07, 0x0b, 0x12, 0xa0, 0x8f,
	0xa0, 0xcd, 0x45, 0x46, 0x49, 0xec, 0x5e, 0x46, 0x24, 0xb0, 0xba, 0x43, 0x63, 0x5c, 0xc3, 0xa0,
	0x4d, 0xdf, 0x44, 0x24, 0x40, 0x3b, 0x50, 0x67, 0xa9, 0x08, 0x59, 0x62, 0xf5, 0x86, 0x9b, 0xe3,
	0xf6, 0xe4, 0xc9, 0x9b, 0x5c, 0x4e, 0x94, 0x77, 0x9e, 0x88, 0x6c, 0x85, 0x8b, 0x50, 0x49, 0xdf,
	0x27, 0x82, 0x58, 0x0f, 0x86, 0xc6, 0xb8, 0xfd, 0x36, 0xfd, 0x3d, 0x22, 0x08, 0x56, 0x11, 0xb2,
	0x7e, 0x42, 0xa9, 0xef, 0xbe, 0x24, 0xd7, 0x34, 0x4f, 0x2d, 0x73, 0x68, 0x8c, 0x9b, 0x18, 0xa4,
	0xe9, 0x85, 0xb2, 0xf4, 0x3f, 0x87, 0x76, 0xa9, 0x82, 0x7c, 0xc1, 0x35, 0x5d, 0x59, 0x86, 0x7e,
	0xc1, 0x35, 0x5d, 0xa1, 0x47, 0x50, 0xbb, 0x25, 0x51, 0x4e, 0xad, 0x8a, 0xb2, 0x69, 0xf0, 0x45,
	0xe5, 0x33, 0xa3, 0xff, 0x4b, 0x05, 0xaa, 0xb2, 0x14, 0x42, 0x50, 0xcd, 0x88, 0xa0, 0x2a, 0xab,
	0x86, 0xd5, 0x19, 0xbd, 0x07, 0xf5, 0x4b, 0x96, 0xc5, 0x44, 0x14, 0x79, 0x05, 0x42, 0x16, 0x34,
	0x88, 0xe7, 0xb1, 0x3c, 0x11, 0xd6, 0x66, 0xd1, 0x3c, 0x0d, 0x51, 0x1f, 0x9a, 0x11, 0x49, 0x82,
	0x9c, 0x04, 0xd4, 0xaa, 0x2a, 0xd7, 0x3d, 0x96, 0x59, 0x7e, 0x48, 0x22, 0xea, 0x09, 0xab, 0xa6,
	0xb3, 0x0a, 0x28, 0xeb, 0xdc, 0xd2, 0xc4, 0x67, 0x99, 0x55, 0xd7, 0x75, 0x34, 0x92, 0x19, 0xde,
	0x15, 0x49, 0x12, 0x1a, 0x59, 0x0d, 0x45, 0x6b, 0x0d, 0x65, 0x1d, 0x3f, 0xcf, 0x88, 0xea, 0x79,
	0x53, 0xb9, 0xee, 0xb1, 0x7c, 0x89, 0x9a, 0x53, 0x4b, 0xbf, 0x44, 0x9e, 0xd1, 0x3b, 0x50, 0xd7,
	0xca, 0x54, 0x22, 0xe8, 0x60, 0xe3, 0x19, 0xda, 0x01, 0x88, 0xf3, 0x68, 0xca, 0xb3, 0x23, 0x92,
	0x04, 0x4a, 0x04, 0xbd, 0xc9, 0xc3, 0xd2, 0x14, 0xa6, 0x3c, 0xe3, 0xd2, 0x85, 0x4b, 0x61, 0xa3,
	0x21, 0x54, 0x95, 0x48, 0x5a, 0x50, 0xdb, 0x3d, 0x3a, 0x99, 0x1d, 0x9a, 0x1b, 0xa8, 0x0b, 0x2d,
	0xe7, 0x0c, 0xcf, 0xa7, 0xc7, 0x07, 0x8b, 0xe7, 0xa6, 0x31, 0xfa, 0xd1, 0x00, 0x84, 0xa9, 0xc7,
	0x82, 0x24, 0x94, 0x6c, 0x30, 0xbd, 0xc9, 0x29, 0x17, 0xe8, 0x2b, 0x78, 0xa0, 0x35, 0xee, 0x66,
	0xf4, 0xc6, 0x0d, 0x93, 0x4b, 0xa6, 0x3a, 0xdd, 0x9e, 0xbc, 0x6b, 0x17, 0xda, 0x9f, 0xa9, 0x0f,
	0xa6, 0x37, 0x07, 0xc9, 0x25, 0xc3, 0x5d, 0xaf, 0x0c, 0xd1, 0x53, 0xa8, 0x5e, 0x30, 0x7f, 0xa5,
	0xe6, 0xd0, 0x9e, 0x3c, 0x78, 0x43, 0x2c, 0x58, 0x39, 0xd1, 0x53, 0xa8, 0xd1, 0x57, 0x22, 0x23,
	0x6a, 0x28, 0xed, 0x49, 0x77, 0x7d, 0xf3, 0x5c, 0x1a, 0xb1, 0xf6, 0x8d, 0x7e, 0xae, 0xc0, 0xc3,
	0xd7, 0xf8, 0xf1, 0x94, 0x25, 0x9c, 0x96, 0x09, 0xf2, 0xf4, 0xbf, 0x08, 0xf2, 0xf4, 0x35, 0x82,
	0x1a, 0xa2, 0xaf, 0xa1, 0xe7, 0x53, 0x41, 0xc2, 0xc8, 0x8d, 0x29, 0xe7, 0x72, 0xfc, 0x9a, 0xea,
	0x63, 0x5b, 0x2f, 0xb3, 0xbd, 0x5e, 0x66, 0xdb, 0x51, 0xcb, 0x8c, 0xbb, 0x3a, 0xfc, 0x58, 0x47,
	0xcb, 0x85, 0x0c, 0xb9, 0x9b, 0xb0, 0x90, 0x53, 0x45, 0xbf, 0x89, 0x1b, 0x21, 0x5f, 0x48, 0x28,
	0xe5, 0xaf, 0x7a, 0x18, 0xb2, 0xc4, 0x0d, 0xfd, 0x42, 0x56, 0xb0, 0x36, 0x1d, 0xf8, 0xe8, 0x09,
	0xb4, 0x42, 0xbe, 0xde, 0x8e, 0x9a, 0x4a, 0x6e, 0x86, 0x5c, 0xef, 0x06, 0xfa, 0x12, 0xba, 0xda,
	0xe3, 0x72, 0x41, 0x44, 0xce, 0x95, 0xc4, 0x7a, 0x93, 0xc7, 0xa5, 0x16, 0xea, 0x48, 0x47, 0xb9,
	0x71, 0xe7, 0x65, 0x09, 0x8d, 0x30, 0x34, 0x67, 0x57, 0xd4, 0xbb, 0x9e, 0xc5, 0xbe, 0x54, 0x29,
	0xf1, 0x94, 0xe2, 0xf4, 0x66, 0x15, 0x48, 0xda, 0x8b, 0xab, 0x2b, 0x4a, 0x71, 0x05, 0x92, 0x76,
	0x2f, 0xf6, 0xf7, 0xb8, 0x57, 0x2c, 0x49, 0x81, 0xb6, 0xa6, 0xd0, 0x29, 0x57, 0x94, 0x02, 0x5a,
	0x9c, 0xb8, 0x2f, 0xa6, 0x87, 0xf3, 0xe5, 0xa9, 0xb9, 0x81, 0x10, 0xf4, 0xf4, 0xd9, 0x75, 0x96,
	0xb3, 0xd9, 0xdc, 0x71, 0x4c, 0x03, 0xf5, 0x00, 0xf6, 0xa7, 0x7b, 0xeb, 0x98, 0xca, 0xd6, 0x12,
	0x9a, 0x6b, 0x79, 0xca, 0xf4, 0xa3, 0xe9, 0xe2, 0xb9, 0x7b, 0x38, 0x9f, 0xcb, 0xf4, 0x36, 0x34,
	0x14, 0x9c, 0xed, 0x9b, 0xc6, 0x3d, 0x98, 0x2f, 0xcc, 0x0a, 0x32, 0xa1, 0xa3, 0x80, 0x73, 0x30,
	0xdb, 0x5f, 0x4e, 0x17, 0xe6, 0xa6, 0xbc, 0x56, 0x59, 0xce, 0x97, 0xf3, 0xf3, 0xa5, 0x59, 0x9d,
	0xfc, 0x69, 0x40, 0xdd, 0x51, 0x6b, 0x82, 0x8e, 0xa0, 0x55, 0xa8, 0xe4, 0x3b, 0x8a, 0x3e, 0x2c,
	0x35, 0xeb, 0x6d, 0x6d, 0xf7, 0x07, 0xff, 0xe6, 0xd6, 0xd2, 0x1a, 0x6d, 0xa0, 0x73, 0x40, 0x8e,
	0xfa, 0x5d, 0x86, 0x49, 0xf0, 0xff, 0x5d, 0x3b, 0x36, 0x3e, 0x36, 0xd0, 0xa7, 0xd0, 0xd8, 0x63,
	0x6a, 0x46, 0xa8, 0xbc, 0xbd, 0xeb, 0xa9, 0xf5, 0xff, 0xc9, 0x38, 0xda, 0xd8, 0x3d, 0xfe, 0xf5,
	0x6e, 0x60, 0xfc, 0x76, 0x37, 0x30, 0x7e, 0xbf, 0x1b, 0x18, 0xdf, 0xff, 0x31, 0xd8, 0x80, 0x81,
	0xc7, 0x62, 0xdb, 0x8b, 0x58, 0xee, 0xc7, 0x61, 0xe2, 0x73, 0xfb, 0x8a, 0x64, 0xe1, 0xab, 0xbf,
	0x93, 0x77, 0xdb, 0xba, 0x33, 0xa7, 0x52, 0xc7, 0xa7, 0xc6, 0xb7, 0xf5, 0xdb, 0x4f, 0xb6, 0x09,
	0xcf, 0x7e, 0xaa, 0x6c, 0x4e, 0x1d, 0x7c, 0x51, 0x57, 0xf2, 0xde, 0xf9, 0x2b, 0x00, 0x00, 0xff,
	0xff, 0x0f, 0x27, 0x41, 0x77, 0x00, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SpeechClient is the client API for Speech service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SpeechClient interface {
	Recognize(ctx context.Context, in *RecognitionRequest, opts ...grpc.CallOption) (*RecognitionResponse, error)
	StreamingRecognize(ctx context.Context, opts ...grpc.CallOption) (Speech_StreamingRecognizeClient, error)
	DoCheck(ctx context.Context, in *CheckCmd, opts ...grpc.CallOption) (*CheckCmd, error)
}

type speechClient struct {
	cc *grpc.ClientConn
}

func NewSpeechClient(cc *grpc.ClientConn) SpeechClient {
	return &speechClient{cc}
}

func (c *speechClient) Recognize(ctx context.Context, in *RecognitionRequest, opts ...grpc.CallOption) (*RecognitionResponse, error) {
	out := new(RecognitionResponse)
	err := c.cc.Invoke(ctx, "/skill.asr.Speech/Recognize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *speechClient) StreamingRecognize(ctx context.Context, opts ...grpc.CallOption) (Speech_StreamingRecognizeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Speech_serviceDesc.Streams[0], "/skill.asr.Speech/StreamingRecognize", opts...)
	if err != nil {
		return nil, err
	}
	x := &speechStreamingRecognizeClient{stream}
	return x, nil
}

type Speech_StreamingRecognizeClient interface {
	Send(*RecognitionRequest) error
	Recv() (*RecognitionResponse, error)
	grpc.ClientStream
}

type speechStreamingRecognizeClient struct {
	grpc.ClientStream
}

func (x *speechStreamingRecognizeClient) Send(m *RecognitionRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *speechStreamingRecognizeClient) Recv() (*RecognitionResponse, error) {
	m := new(RecognitionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *speechClient) DoCheck(ctx context.Context, in *CheckCmd, opts ...grpc.CallOption) (*CheckCmd, error) {
	out := new(CheckCmd)
	err := c.cc.Invoke(ctx, "/skill.asr.Speech/DoCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SpeechServer is the server API for Speech service.
type SpeechServer interface {
	Recognize(context.Context, *RecognitionRequest) (*RecognitionResponse, error)
	StreamingRecognize(Speech_StreamingRecognizeServer) error
	DoCheck(context.Context, *CheckCmd) (*CheckCmd, error)
}

// UnimplementedSpeechServer can be embedded to have forward compatible implementations.
type UnimplementedSpeechServer struct {
}

func (*UnimplementedSpeechServer) Recognize(ctx context.Context, req *RecognitionRequest) (*RecognitionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Recognize not implemented")
}
func (*UnimplementedSpeechServer) StreamingRecognize(srv Speech_StreamingRecognizeServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamingRecognize not implemented")
}
func (*UnimplementedSpeechServer) DoCheck(ctx context.Context, req *CheckCmd) (*CheckCmd, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DoCheck not implemented")
}

func RegisterSpeechServer(s *grpc.Server, srv SpeechServer) {
	s.RegisterService(&_Speech_serviceDesc, srv)
}

func _Speech_Recognize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecognitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpeechServer).Recognize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/skill.asr.Speech/Recognize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpeechServer).Recognize(ctx, req.(*RecognitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Speech_StreamingRecognize_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SpeechServer).StreamingRecognize(&speechStreamingRecognizeServer{stream})
}

type Speech_StreamingRecognizeServer interface {
	Send(*RecognitionResponse) error
	Recv() (*RecognitionRequest, error)
	grpc.ServerStream
}

type speechStreamingRecognizeServer struct {
	grpc.ServerStream
}

func (x *speechStreamingRecognizeServer) Send(m *RecognitionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *speechStreamingRecognizeServer) Recv() (*RecognitionRequest, error) {
	m := new(RecognitionRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Speech_DoCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckCmd)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpeechServer).DoCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/skill.asr.Speech/DoCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpeechServer).DoCheck(ctx, req.(*CheckCmd))
	}
	return interceptor(ctx, in, info, handler)
}

var _Speech_serviceDesc = grpc.ServiceDesc{
	ServiceName: "skill.asr.Speech",
	HandlerType: (*SpeechServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Recognize",
			Handler:    _Speech_Recognize_Handler,
		},
		{
			MethodName: "DoCheck",
			Handler:    _Speech_DoCheck_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamingRecognize",
			Handler:       _Speech_StreamingRecognize_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "speech.proto",
}

func (m *Body) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Body) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Body) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NeedWakeup {
		i--
		if m.NeedWakeup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpeech(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Option) > 0 {
		for k := range m.Option {
			v := m.Option[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSpeech(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSpeech(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSpeech(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x72
		}
	}
	if m.StreamFlag != 0 {
		i = encodeVarintSpeech(dAtA, i, uint64(m.StreamFlag))
		i--
		dAtA[i] = 0x68
	}
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.AppType) > 0 {
		i -= len(m.AppType)
		copy(dAtA[i:], m.AppType)
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.AppType)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Sid) > 0 {
		i -= len(m.Sid)
		copy(dAtA[i:], m.Sid)
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.Sid)))
		i--
		dAtA[i] = 0x52
	}
	if m.Type != 0 {
		i = encodeVarintSpeech(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x48
	}
	return len(dAtA) - i, nil
}

func (m *Body_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Body_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Body_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MulAsrLang != 0 {
		i = encodeVarintSpeech(dAtA, i, uint64(m.MulAsrLang))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Speech) > 0 {
		i -= len(m.Speech)
		copy(dAtA[i:], m.Speech)
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.Speech)))
		i--
		dAtA[i] = 0x52
	}
	if m.Flag != 0 {
		i = encodeVarintSpeech(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x48
	}
	if m.Duration != 0 {
		i = encodeVarintSpeech(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x40
	}
	if m.Channel != 0 {
		i = encodeVarintSpeech(dAtA, i, uint64(m.Channel))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Vendor) > 0 {
		i -= len(m.Vendor)
		copy(dAtA[i:], m.Vendor)
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.Vendor)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Dialect) > 0 {
		i -= len(m.Dialect)
		copy(dAtA[i:], m.Dialect)
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.Dialect)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Language) > 0 {
		i -= len(m.Language)
		copy(dAtA[i:], m.Language)
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.Language)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x12
	}
	if m.Rate != 0 {
		i = encodeVarintSpeech(dAtA, i, uint64(m.Rate))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecognitionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecognitionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecognitionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Extra != nil {
		{
			size, err := m.Extra.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpeech(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpeech(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CommonReqInfo != nil {
		{
			size, err := m.CommonReqInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpeech(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecognitionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecognitionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecognitionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WakeupStatus != 0 {
		i = encodeVarintSpeech(dAtA, i, uint64(m.WakeupStatus))
		i--
		dAtA[i] = 0x30
	}
	if m.IsWakeup {
		i--
		if m.IsWakeup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.QuestionId) > 0 {
		i -= len(m.QuestionId)
		copy(dAtA[i:], m.QuestionId)
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.QuestionId)))
		i--
		dAtA[i] = 0x22
	}
	if m.IsNoise {
		i--
		if m.IsNoise {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.DetailMessage != nil {
		{
			size, err := m.DetailMessage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpeech(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CommonRspInfo != nil {
		{
			size, err := m.CommonRspInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpeech(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CmdDsc) > 0 {
		i -= len(m.CmdDsc)
		copy(dAtA[i:], m.CmdDsc)
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.CmdDsc)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintSpeech(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Action) > 0 {
		i -= len(m.Action)
		copy(dAtA[i:], m.Action)
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.Action)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSpeech(dAtA []byte, offset int, v uint64) int {
	offset -= sovSpeech(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Body) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovSpeech(uint64(m.Type))
	}
	l = len(m.Sid)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	l = len(m.AppType)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.StreamFlag != 0 {
		n += 1 + sovSpeech(uint64(m.StreamFlag))
	}
	if len(m.Option) > 0 {
		for k, v := range m.Option {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSpeech(uint64(len(k))) + 1 + len(v) + sovSpeech(uint64(len(v)))
			n += mapEntrySize + 1 + sovSpeech(uint64(mapEntrySize))
		}
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.NeedWakeup {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Body_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rate != 0 {
		n += 1 + sovSpeech(uint64(m.Rate))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	l = len(m.Dialect)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.Channel != 0 {
		n += 1 + sovSpeech(uint64(m.Channel))
	}
	if m.Duration != 0 {
		n += 1 + sovSpeech(uint64(m.Duration))
	}
	if m.Flag != 0 {
		n += 1 + sovSpeech(uint64(m.Flag))
	}
	l = len(m.Speech)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.MulAsrLang != 0 {
		n += 1 + sovSpeech(uint64(m.MulAsrLang))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecognitionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommonReqInfo != nil {
		l = m.CommonReqInfo.Size()
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.Extra != nil {
		l = m.Extra.Size()
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecognitionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommonRspInfo != nil {
		l = m.CommonRspInfo.Size()
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.DetailMessage != nil {
		l = m.DetailMessage.Size()
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.IsNoise {
		n += 2
	}
	l = len(m.QuestionId)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.IsWakeup {
		n += 2
	}
	if m.WakeupStatus != 0 {
		n += 1 + sovSpeech(uint64(m.WakeupStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovSpeech(uint64(m.Status))
	}
	l = len(m.CmdDsc)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSpeech(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSpeech(x uint64) (n int) {
	return sovSpeech(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Body) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Body: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Body: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Body_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamFlag", wireType)
			}
			m.StreamFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Option == nil {
				m.Option = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpeech
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpeech
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSpeech
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSpeech
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpeech
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSpeech
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSpeech
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpeech(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpeech
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Option[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &Body_Data{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedWakeup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedWakeup = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Body_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dialect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dialect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speech", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Speech = append(m.Speech[:0], dAtA[iNdEx:postIndex]...)
			if m.Speech == nil {
				m.Speech = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MulAsrLang", wireType)
			}
			m.MulAsrLang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MulAsrLang |= AsrsLang(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecognitionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecognitionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecognitionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonReqInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommonReqInfo == nil {
				m.CommonReqInfo = &common.CommonReqInfo{}
			}
			if err := m.CommonReqInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &Body{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extra == nil {
				m.Extra = &common.Extra{}
			}
			if err := m.Extra.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecognitionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecognitionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecognitionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonRspInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommonRspInfo == nil {
				m.CommonRspInfo = &common.CommonRspInfo{}
			}
			if err := m.CommonRspInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetailMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DetailMessage == nil {
				m.DetailMessage = &types.Struct{}
			}
			if err := m.DetailMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNoise", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNoise = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuestionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuestionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWakeup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWakeup = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WakeupStatus", wireType)
			}
			m.WakeupStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WakeupStatus |= WakeupStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdDsc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CmdDsc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSpeech(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSpeech
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSpeech
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSpeech
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSpeech        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSpeech          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSpeech = fmt.Errorf("proto: unexpected end of group")
)
